"""
Идея 4. Степени двойки
"""
"""
В последовательности натуральных чисел, не превосходящих 1000, найти количество пар, 
сумма элементов в которых делится на m = 87 и элемент с бОльшим индексом больше элемента
с меньшим индексом. 
"""


def get_bits_count(n):
    """
    Возвращает количество единиц в двоичной записи числа n. 
    Источник: geeksforgeeks.org
    Таблица соответствий чисел от 0 до 15:
    Десятичное Двоичное Число единиц
    0          0        0
    1          1        1
    2          10       1
    3          11       2
    4          100      1
    5          101      2
    6          110      2
    7          111      3
    8          1000     1
    9          1001     2
    10         1010     2
    11         1011     3
    12         1100     2
    13         1101     3
    14         1110     3
    15         1111     4
    Зная количество единиц для числа из четырех цифр, рекурсивно посчитаем
    общее количество единиц путем постоянного деления на 16 = 2 ** 4.
    """
    number_of_bits = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]
    if n == 0:
        return 0
    return number_of_bits[n % 16] + get_bits_count(n // 16)


# Здесь все стандартно
n = int(input())
m = 87
total_count = 0
numbers = [0 for _ in range(m)]
for i in range(n):
    # Вводим число
    x = int(input())
    # r - остаток от деления текущего числа на m
    r = x % m
    # pr - "парный" остаток от деления
    pr = (m - r) % m
    # k - целая часть от деления x на m
    k = x // m
    # p - сокращение от power - степень двойки для данного числа
    # gp - степень двойки, больше этой степени нельзя брать числа
    p = gp = 2 ** k 
    # Оговорено выше, что если остаток больше половины,
    # то число с таким же k, но парным остатком нам подойдет
    if r > pr:
        gp *= 2
    # Здесь опять все стандартно.
    total_count += get_bits_count(numbers[pr] % gp)
    numbers[r] += p
        
print(total_count)
